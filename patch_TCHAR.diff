diff --git a/MozJpegGUI/MozJpegGUI/CConvert.cpp b/MozJpegGUI/MozJpegGUI/CConvert.cpp
index ba137bc..3d00f08 100644
--- a/MozJpegGUI/MozJpegGUI/CConvert.cpp
+++ b/MozJpegGUI/MozJpegGUI/CConvert.cpp
@@ -304,14 +304,14 @@ bool CConvert::Convert()
 	int argc;
 	void** argv;
 	int ret;
-	CreateArgs(&argc, &argv);
+	CreateArgs(&argc, (TCHAR***) &argv);
 	CJpeg jpeg;
 	jpeg.m_pSyncAbort = &m_pParent->m_SyncAbort;
 	jpeg.m_Paused = &m_pParent->m_Paused;
 
 	OutputDebugLog(_T("Start convertion\n"));
 
-	ret = jpeg.cjpeg_main(argc, (char**)argv);
+	ret = jpeg.cjpeg_main(argc, (TCHAR**)argv);
 
 	OutputDebugLog(_T("Completed convertion\n"));
 
@@ -503,7 +503,7 @@ DWORD CConvertLock::Unlock()
 }
 
 
-void CConvert::CreateArgs(int* argc, void*** argv)
+void CConvert::CreateArgs(int* argc, TCHAR*** argv)
 {
 	CString cmd = m_CommandOptions;
 	int curpos = 0;
@@ -523,13 +523,12 @@ void CConvert::CreateArgs(int* argc, void*** argv)
 	vec.push_back(m_Filename);
 
 	*argc = static_cast<int>(vec.size());
-	*argv = new void*[*argc];
+	*argv = new TCHAR*[*argc];
 	int i;
 
 	for (i = 0; i < *argc; i++) {
-		CStringA aBuff = CT2A(vec[i]);
-		(*argv)[i] = new char[aBuff.GetLength() + 1];
-		strcpy_s(static_cast<char *>((*argv)[i]), aBuff.GetLength()+1, aBuff);
+		(*argv)[i] = new TCHAR[vec[i].GetLength() + 1];
+		_tcscpy_s(static_cast<TCHAR *>((*argv)[i]), vec[i].GetLength() + 1, vec[i]);
 	}
 }
 
diff --git a/MozJpegGUI/MozJpegGUI/CConvert.h b/MozJpegGUI/MozJpegGUI/CConvert.h
index cc2382c..643069a 100644
--- a/MozJpegGUI/MozJpegGUI/CConvert.h
+++ b/MozJpegGUI/MozJpegGUI/CConvert.h
@@ -31,7 +31,7 @@ public:
 	bool ReadFile();
 	bool Convert();
 	bool WriteFile();
-	void CreateArgs(int* argc, void*** argv);
+	void CreateArgs(int* argc, TCHAR*** argv);
 };
 
 class CConvertLock
diff --git a/MozJpegGUI/MozJpegGUI/CLibPNGVer.cpp b/MozJpegGUI/MozJpegGUI/CLibPNGVer.cpp
index a1f2e72..7f35573 100644
--- a/MozJpegGUI/MozJpegGUI/CLibPNGVer.cpp
+++ b/MozJpegGUI/MozJpegGUI/CLibPNGVer.cpp
@@ -5,7 +5,7 @@
 
 CString CLibPNGVer::GetLibPNGVer()
 {
-	return CString(_T(PNG_HEADER_VERSION_STRING));
+	return CString(PNG_HEADER_VERSION_STRING);
 }
 
 CString CLibPNGVer::GetZLibVer()
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.cpp b/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.cpp
index 45221eb..0c8d684 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.cpp
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.cpp
@@ -96,13 +96,13 @@ end_progress_monitor(j_common_ptr cinfo)
  */
 
 GLOBAL(boolean)
-keymatch(char *arg, const char *keyword, int minchars)
+keymatch(TCHAR *arg, const TCHAR *keyword, int minchars)
 {
   register int ca, ck;
   register int nmatched = 0;
 
-  while ((ca = *arg++) != '\0') {
-    if ((ck = *keyword++) == '\0')
+  while ((ca = *arg++) != _T('\0')) {
+    if ((ck = *keyword++) == _T('\0'))
       return FALSE;             /* arg longer than keyword, no good */
     if (isupper(ca))            /* force arg to lcase (assume ck is already) */
       ca = tolower(ca);
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.h b/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.h
index ae87c34..bbcac78 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.h
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/cdjpeg.h
@@ -128,13 +128,13 @@ EXTERN(djpeg_dest_ptr) jinit_write_targa(j_decompress_ptr cinfo);
 
 /* cjpeg support routines (in rdswitch.c) */
 
-EXTERN(boolean) read_quant_tables(j_compress_ptr cinfo, char *filename,
+EXTERN(boolean) read_quant_tables(j_compress_ptr cinfo, TCHAR *filename,
                                   boolean force_baseline);
-EXTERN(boolean) read_scan_script(j_compress_ptr cinfo, char *filename);
-EXTERN(boolean) set_quality_ratings(j_compress_ptr cinfo, char *arg,
+EXTERN(boolean) read_scan_script(j_compress_ptr cinfo, TCHAR *filename);
+EXTERN(boolean) set_quality_ratings(j_compress_ptr cinfo, TCHAR *arg,
                                     boolean force_baseline);
-EXTERN(boolean) set_quant_slots(j_compress_ptr cinfo, char *arg);
-EXTERN(boolean) set_sample_factors(j_compress_ptr cinfo, char *arg);
+EXTERN(boolean) set_quant_slots(j_compress_ptr cinfo, TCHAR *arg);
+EXTERN(boolean) set_sample_factors(j_compress_ptr cinfo, TCHAR *arg);
 
 /* djpeg support routines (in rdcolmap.c) */
 
@@ -145,7 +145,7 @@ EXTERN(void) read_color_map(j_decompress_ptr cinfo, FILE *infile);
 EXTERN(void) start_progress_monitor(j_common_ptr cinfo,
                                     cd_progress_ptr progress);
 EXTERN(void) end_progress_monitor(j_common_ptr cinfo);
-EXTERN(boolean) keymatch(char *arg, const char *keyword, int minchars);
+EXTERN(boolean) keymatch(TCHAR *arg, const TCHAR *keyword, int minchars);
 EXTERN(FILE *) read_stdin(void);
 EXTERN(FILE *) write_stdout(void);
 
@@ -155,8 +155,8 @@ EXTERN(FILE *) write_stdout(void);
 #define READ_BINARY     "r"
 #define WRITE_BINARY    "w"
 #else
-#define READ_BINARY     "rb"
-#define WRITE_BINARY    "wb"
+#define READ_BINARY     _T("rb")
+#define WRITE_BINARY    _T("wb")
 #endif
 
 #ifndef EXIT_FAILURE            /* define exit() codes if not provided */
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.cpp b/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.cpp
index c15222c..c74d1a8 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.cpp
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.cpp
@@ -221,97 +221,97 @@ cjpeg_source_ptr CJpeg::select_file_type(FILE* infile)
 void CJpeg::usage()
 /* complain about bad command line */
 {
-  fprintf(stderr, "usage: %s [switches] ", m_progname);
+  _ftprintf(stderr, _T("usage: %s [switches] "), m_progname);
 #ifdef TWO_FILE_COMMANDLINE
-  fprintf(stderr, "inputfile outputfile\n");
+  _ftprintf(stderr, "inputfile outputfile\n");
 #else
-  fprintf(stderr, "[inputfile]\n");
+  _ftprintf(stderr, _T("[inputfile]\n"));
 #endif
 
-  fprintf(stderr, "Switches (names may be abbreviated):\n");
-  fprintf(stderr, "  -quality N[,...]   Compression quality (0..100; 5-95 is most useful range,\n");
-  fprintf(stderr, "                     default is 75)\n");
-  fprintf(stderr, "  -grayscale     Create monochrome JPEG file\n");
-  fprintf(stderr, "  -rgb           Create RGB JPEG file\n");
+  _ftprintf(stderr, _T("Switches (names may be abbreviated):\n"));
+  _ftprintf(stderr, _T("  -quality N[,...]   Compression quality (0..100; 5-95 is most useful range,\n"));
+  _ftprintf(stderr, _T("                     default is 75)\n"));
+  _ftprintf(stderr, _T("  -grayscale     Create monochrome JPEG file\n"));
+  _ftprintf(stderr, _T("  -rgb           Create RGB JPEG file\n"));
 #ifdef ENTROPY_OPT_SUPPORTED
-  fprintf(stderr, "  -optimize      Optimize Huffman table (smaller file, but slow compression, enabled by default)\n");
+  _ftprintf(stderr, _T("  -optimize      Optimize Huffman table (smaller file, but slow compression, enabled by default)\n"));
 #endif
 #ifdef C_PROGRESSIVE_SUPPORTED
-  fprintf(stderr, "  -progressive   Create progressive JPEG file (enabled by default)\n");
+  _ftprintf(stderr, _T("  -progressive   Create progressive JPEG file (enabled by default)\n"));
 #endif
-  fprintf(stderr, "  -baseline      Create baseline JPEG file (disable progressive coding)\n");
+  _ftprintf(stderr, _T("  -baseline      Create baseline JPEG file (disable progressive coding)\n"));
 #ifdef TARGA_SUPPORTED
-  fprintf(stderr, "  -targa         Input file is Targa format (usually not needed)\n");
+  _ftprintf(stderr, _T("  -targa         Input file is Targa format (usually not needed)\n"));
 #endif
-  fprintf(stderr, "  -revert        Revert to standard defaults (instead of mozjpeg defaults)\n");
-  fprintf(stderr, "  -fastcrush     Disable progressive scan optimization\n");
-  fprintf(stderr, "  -dc-scan-opt   DC scan optimization mode\n");
-  fprintf(stderr, "                 - 0 One scan for all components\n");
-  fprintf(stderr, "                 - 1 One scan per component (default)\n");
-  fprintf(stderr, "                 - 2 Optimize between one scan for all components and one scan for 1st component\n");
-  fprintf(stderr, "                     plus one scan for remaining components\n");
-  fprintf(stderr, "  -notrellis     Disable trellis optimization\n");
-  fprintf(stderr, "  -trellis-dc    Enable trellis optimization of DC coefficients (default)\n");
-  fprintf(stderr, "  -notrellis-dc  Disable trellis optimization of DC coefficients\n");
-  fprintf(stderr, "  -tune-psnr     Tune trellis optimization for PSNR\n");
-  fprintf(stderr, "  -tune-hvs-psnr Tune trellis optimization for PSNR-HVS (default)\n");
-  fprintf(stderr, "  -tune-ssim     Tune trellis optimization for SSIM\n");
-  fprintf(stderr, "  -tune-ms-ssim  Tune trellis optimization for MS-SSIM\n");
-  fprintf(stderr, "Switches for advanced users:\n");
-  fprintf(stderr, "  -noovershoot   Disable black-on-white deringing via overshoot\n");
-  fprintf(stderr, "  -nojfif        Do not write JFIF (reduces size by 18 bytes but breaks standards; no known problems in Web browsers)\n");
+  _ftprintf(stderr, _T("  -revert        Revert to standard defaults (instead of mozjpeg defaults)\n"));
+  _ftprintf(stderr, _T("  -fastcrush     Disable progressive scan optimization\n"));
+  _ftprintf(stderr, _T("  -dc-scan-opt   DC scan optimization mode\n"));
+  _ftprintf(stderr, _T("                 - 0 One scan for all components\n"));
+  _ftprintf(stderr, _T("                 - 1 One scan per component (default)\n"));
+  _ftprintf(stderr, _T("                 - 2 Optimize between one scan for all components and one scan for 1st component\n"));
+  _ftprintf(stderr, _T("                     plus one scan for remaining components\n"));
+  _ftprintf(stderr, _T("  -notrellis     Disable trellis optimization\n"));
+  _ftprintf(stderr, _T("  -trellis-dc    Enable trellis optimization of DC coefficients (default)\n"));
+  _ftprintf(stderr, _T("  -notrellis-dc  Disable trellis optimization of DC coefficients\n"));
+  _ftprintf(stderr, _T("  -tune-psnr     Tune trellis optimization for PSNR\n"));
+  _ftprintf(stderr, _T("  -tune-hvs-psnr Tune trellis optimization for PSNR-HVS (default)\n"));
+  _ftprintf(stderr, _T("  -tune-ssim     Tune trellis optimization for SSIM\n"));
+  _ftprintf(stderr, _T("  -tune-ms-ssim  Tune trellis optimization for MS-SSIM\n"));
+  _ftprintf(stderr, _T("Switches for advanced users:\n"));
+  _ftprintf(stderr, _T("  -noovershoot   Disable black-on-white deringing via overshoot\n"));
+  _ftprintf(stderr, _T("  -nojfif        Do not write JFIF (reduces size by 18 bytes but breaks standards; no known problems in Web browsers)\n"));
 #ifdef C_ARITH_CODING_SUPPORTED
-  fprintf(stderr, "  -arithmetic    Use arithmetic coding\n");
+  _ftprintf(stderr, _T("  -arithmetic    Use arithmetic coding\n"));
 #endif
 #ifdef DCT_ISLOW_SUPPORTED
-  fprintf(stderr, "  -dct int       Use accurate integer DCT method%s\n",
-          (JDCT_DEFAULT == JDCT_ISLOW ? " (default)" : ""));
+  _ftprintf(stderr, _T("  -dct int       Use accurate integer DCT method%s\n"),
+          (JDCT_DEFAULT == JDCT_ISLOW ? _T(" (default)") : _T("")));
 #endif
 #ifdef DCT_IFAST_SUPPORTED
-  fprintf(stderr, "  -dct fast      Use less accurate integer DCT method [legacy feature]%s\n",
-	(JDCT_DEFAULT == JDCT_IFAST ? " (default)" : ""));
+  _ftprintf(stderr, _T("  -dct fast      Use less accurate integer DCT method [legacy feature]%s\n"),
+	(JDCT_DEFAULT == JDCT_IFAST ? _T(" (default)") : _T("")));
 #endif
 #ifdef DCT_FLOAT_SUPPORTED
-  fprintf(stderr, "  -dct float     Use floating-point DCT method [legacy feature]%s\n",
-          (JDCT_DEFAULT == JDCT_FLOAT ? " (default)" : ""));
+  _ftprintf(stderr, _T("  -dct float     Use floating-point DCT method [legacy feature]%s\n"),
+          (JDCT_DEFAULT == JDCT_FLOAT ? _T(" (default)") : _T("")));
 #endif
-  fprintf(stderr, "  -quant-baseline Use 8-bit quantization table entries for baseline JPEG compatibility\n");
-  fprintf(stderr, "  -quant-table N Use predefined quantization table N:\n");
-  fprintf(stderr, "                 - 0 JPEG Annex K\n");
-  fprintf(stderr, "                 - 1 Flat\n");
-  fprintf(stderr, "                 - 2 Tuned for MS-SSIM on Kodak image set\n");
-  fprintf(stderr, "                 - 3 ImageMagick table by N. Robidoux (default)\n");
-  fprintf(stderr, "                 - 4 Tuned for PSNR-HVS on Kodak image set\n");
-  fprintf(stderr, "                 - 5 Table from paper by Klein, Silverstein and Carney\n");
-  fprintf(stderr, "                 - 6 Table from paper by Watson, Taylor and Borthwick\n");
-  fprintf(stderr, "                 - 7 Table from paper by Ahumada, Watson, Peterson\n");
-  fprintf(stderr, "                 - 8 Table from paper by Peterson, Ahumada and Watson\n");
-  fprintf(stderr, "  -icc FILE      Embed ICC profile contained in FILE\n");
-  fprintf(stderr, "  -restart N     Set restart interval in rows, or in blocks with B\n");
+  _ftprintf(stderr, _T("  -quant-baseline Use 8-bit quantization table entries for baseline JPEG compatibility\n"));
+  _ftprintf(stderr, _T("  -quant-table N Use predefined quantization table N:\n"));
+  _ftprintf(stderr, _T("                 - 0 JPEG Annex K\n"));
+  _ftprintf(stderr, _T("                 - 1 Flat\n"));
+  _ftprintf(stderr, _T("                 - 2 Tuned for MS-SSIM on Kodak image set\n"));
+  _ftprintf(stderr, _T("                 - 3 ImageMagick table by N. Robidoux (default)\n"));
+  _ftprintf(stderr, _T("                 - 4 Tuned for PSNR-HVS on Kodak image set\n"));
+  _ftprintf(stderr, _T("                 - 5 Table from paper by Klein, Silverstein and Carney\n"));
+  _ftprintf(stderr, _T("                 - 6 Table from paper by Watson, Taylor and Borthwick\n"));
+  _ftprintf(stderr, _T("                 - 7 Table from paper by Ahumada, Watson, Peterson\n"));
+  _ftprintf(stderr, _T("                 - 8 Table from paper by Peterson, Ahumada and Watson\n"));
+  _ftprintf(stderr, _T("  -icc FILE      Embed ICC profile contained in FILE\n"));
+  _ftprintf(stderr, _T("  -restart N     Set restart interval in rows, or in blocks with B\n"));
 #ifdef INPUT_SMOOTHING_SUPPORTED
-  fprintf(stderr, "  -smooth N      Smooth dithered input (N=1..100 is strength)\n");
+  _ftprintf(stderr, _T("  -smooth N      Smooth dithered input (N=1..100 is strength)\n"));
 #endif
-  fprintf(stderr, "  -maxmemory N   Maximum memory to use (in kbytes)\n");
-  fprintf(stderr, "  -outfile name  Specify name for output file\n");
+  _ftprintf(stderr, _T("  -maxmemory N   Maximum memory to use (in kbytes)\n"));
+  _ftprintf(stderr, _T("  -outfile name  Specify name for output file\n"));
 #if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)
-  fprintf(stderr, "  -memdst        Compress to memory instead of file (useful for benchmarking)\n");
+  _ftprintf(stderr, _T("  -memdst        Compress to memory instead of file (useful for benchmarking)\n"));
 #endif
-  fprintf(stderr, "  -report        Report compression progress\n");
-  fprintf(stderr, "  -strict        Treat all warnings as fatal\n");
-  fprintf(stderr, "  -verbose  or  -debug   Emit debug output\n");
-  fprintf(stderr, "  -version       Print version information and exit\n");
-  fprintf(stderr, "Switches for wizards:\n");
-  fprintf(stderr, "  -qtables FILE  Use quantization tables given in FILE\n");
-  fprintf(stderr, "  -qslots N[,...]    Set component quantization tables\n");
-  fprintf(stderr, "  -sample HxV[,...]  Set component sampling factors\n");
+  _ftprintf(stderr, _T("  -report        Report compression progress\n"));
+  _ftprintf(stderr, _T("  -strict        Treat all warnings as fatal\n"));
+  _ftprintf(stderr, _T("  -verbose  or  -debug   Emit debug output\n"));
+  _ftprintf(stderr, _T("  -version       Print version information and exit\n"));
+  _ftprintf(stderr, _T("Switches for wizards:\n"));
+  _ftprintf(stderr, _T("  -qtables FILE  Use quantization tables given in FILE\n"));
+  _ftprintf(stderr, _T("  -qslots N[,...]    Set component quantization tables\n"));
+  _ftprintf(stderr, _T("  -sample HxV[,...]  Set component sampling factors\n"));
 #ifdef C_MULTISCAN_FILES_SUPPORTED
-  fprintf(stderr, "  -scans FILE    Create multi-scan JPEG per script FILE\n");
+  _ftprintf(stderr, _T("  -scans FILE    Create multi-scan JPEG per script FILE\n"));
 #endif
   ERREXIT(&m_cinfo, JERR_CJPEG_SHOW_USAGE);
 }
 
 
-int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean for_real)
+int CJpeg::parse_switches(int argc, TCHAR** argv, int last_file_arg_seen, boolean for_real)
 /* Parse optional switches.
  * Returns argv[] index of first file-name argument (== argc if none).
  * Any file names with indexes <= last_file_arg_seen are ignored;
@@ -324,14 +324,14 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 	OutputDebugLog(L"CJpeg::parse_switches\n");
 
 	int argn;
-	char* arg;
+	TCHAR* arg;
 	boolean force_baseline;
 	boolean simple_progressive;
-	char* qualityarg = NULL;      /* saves -quality parm if any */
-	char* qtablefile = NULL;      /* saves -qtables filename if any */
-	char* qslotsarg = NULL;       /* saves -qslots parm if any */
-	char* samplearg = NULL;       /* saves -sample parm if any */
-	char* scansarg = NULL;        /* saves -scans parm if any */
+	TCHAR* qualityarg = NULL;      /* saves -quality parm if any */
+	TCHAR* qtablefile = NULL;      /* saves -qtables filename if any */
+	TCHAR* qslotsarg = NULL;       /* saves -qslots parm if any */
+	TCHAR* samplearg = NULL;       /* saves -sample parm if any */
+	TCHAR* scansarg = NULL;        /* saves -scans parm if any */
 
 	/* Set up default JPEG parameters. */
 
@@ -347,7 +347,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 
 	for (argn = 1; argn < argc; argn++) {
 		arg = argv[argn];
-		if (*arg != '-') {
+		if (*arg != _T('-')) {
 			/* Not a switch, must be a file name argument */
 			if (argn <= last_file_arg_seen) {
 				m_outfilename = NULL;     /* -outfile applies to just one input file */
@@ -357,7 +357,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 		}
 		arg++;                      /* advance past switch marker character */
 
-		if (keymatch(arg, "arithmetic", 1)) {
+		if (keymatch(arg, _T("arithmetic"), 1)) {
 			/* Use arithmetic coding. */
 #ifdef C_ARITH_CODING_SUPPORTED
 			m_cinfo.arith_code = TRUE;
@@ -368,7 +368,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_ARITHMATIC);
 #endif
 		}
-		else if (keymatch(arg, "baseline", 1)) {
+		else if (keymatch(arg, _T("baseline"), 1)) {
 			/* Force baseline-compatible output (8-bit quantizer values). */
 			force_baseline = TRUE;
 			/* Disable multiple scans */
@@ -376,19 +376,19 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			m_cinfo.num_scans = 0;
 			m_cinfo.scan_info = NULL;
 		}
-		else if (keymatch(arg, "dct", 2)) {
+		else if (keymatch(arg, _T("dct"), 2)) {
 			/* Select DCT algorithm. */
 			if (++argn >= argc) {      /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_DCT);
 				usage();
 			}
-			if (keymatch(argv[argn], "int", 1)) {
+			if (keymatch(argv[argn], _T("int"), 1)) {
 				m_cinfo.dct_method = JDCT_ISLOW;
 			}
-			else if (keymatch(argv[argn], "fast", 2)) {
+			else if (keymatch(argv[argn], _T("fast"), 2)) {
 				m_cinfo.dct_method = JDCT_IFAST;
 			}
-			else if (keymatch(argv[argn], "float", 2)) {
+			else if (keymatch(argv[argn], _T("float"), 2)) {
 				m_cinfo.dct_method = JDCT_FLOAT;
 			}
 			else {
@@ -396,50 +396,50 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 				usage();
 			}
 		}
-		else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
+		else if (keymatch(arg, _T("debug"), 1) || keymatch(arg, _T("verbose"), 1)) {
 			/* Enable debug printouts. */
 
-			fprintf(stderr, "%s version %s (build %s)\n",
+			_ftprintf(stderr, _T("%s version %s (build %s)\n"),
 				PACKAGE_NAME, VERSION, BUILD);
-			fprintf(stderr, "%s\n\n", JCOPYRIGHT);
-			fprintf(stderr, "Emulating The Independent JPEG Group's software, version %s\n\n",
+			_ftprintf(stderr, _T("%s\n\n"), _T(JCOPYRIGHT));
+			_ftprintf(stderr, _T("Emulating The Independent JPEG Group's software, version %s\n\n"),
 				JVERSION);
 			m_cinfo.err->trace_level++;
 		}
-		else if (keymatch(arg, "version", 4)) {
-			char buff[JMSG_STR_PARM_MAX];
-			sprintf_s(buff, JMSG_STR_PARM_MAX, "%s version %s (build %s)\n",
+		else if (keymatch(arg, _T("version"), 4)) {
+			TCHAR buff[JMSG_STR_PARM_MAX];
+			_stprintf_s(buff, JMSG_STR_PARM_MAX, _T("%s version %s (build %s)\n"),
 				PACKAGE_NAME, VERSION, BUILD);
 			ERREXITS(&m_cinfo, JERR_CJPEG_SWITCH_VERSION, buff);
 		}
-		else if (keymatch(arg, "fastcrush", 4)) {
+		else if (keymatch(arg, _T("fastcrush"), 4)) {
 			jpeg_c_set_bool_param(&m_cinfo, JBOOLEAN_OPTIMIZE_SCANS, FALSE);
 		}
-		else if (keymatch(arg, "grayscale", 2) || keymatch(arg, "greyscale", 2)) {
+		else if (keymatch(arg, _T("grayscale"), 2) || keymatch(arg, _T("greyscale"), 2)) {
 			/* Force a monochrome JPEG file to be generated. */
 			jpeg_set_colorspace(&m_cinfo, JCS_GRAYSCALE);
 		}
-		else if (keymatch(arg, "rgb", 3)) {
+		else if (keymatch(arg, _T("rgb"), 3)) {
 			/* Force an RGB JPEG file to be generated. */
 			jpeg_set_colorspace(&m_cinfo, JCS_RGB);
 		}
-		else if (keymatch(arg, "lambda1", 7)) {
+		else if (keymatch(arg, _T("lambda1"), 7)) {
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_LAMDA1);
 				usage();
 			}
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE1,
-				static_cast<float>(atof(argv[argn])));
+				static_cast<float>(_ttof(argv[argn])));
 		}
-		else if (keymatch(arg, "lambda2", 7)) {
+		else if (keymatch(arg, _T("lambda2"), 7)) {
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_LAMDA2);
 				usage();
 			}
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE2,
-				static_cast<float>(atof(argv[argn])));
+				static_cast<float>(_ttof(argv[argn])));
 		}
-		else if (keymatch(arg, "icc", 1)) {
+		else if (keymatch(arg, _T("icc"), 1)) {
 			/* Set ICC filename. */
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_ICC);
@@ -447,31 +447,31 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			}
 			m_icc_filename = argv[argn];
 		}
-		else if (keymatch(arg, "maxmemory", 3)) {
+		else if (keymatch(arg, _T("maxmemory"), 3)) {
 			/* Maximum memory in Kb (or Mb with 'm'). */
 			long lval;
-			char ch = 'x';
+			TCHAR ch = _T('x');
 
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_MAXMEMORY);
 				usage();
 			}
-			if (sscanf_s(argv[argn], "%ld%c", &lval, &ch, 1) < 1) {
+			if (_stscanf_s(argv[argn], _T("%ld%c"), &lval, &ch, 1) < 1) {
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_MAXMEMORY);
 				usage();
 			}
-			if (ch == 'm' || ch == 'M')
+			if (ch == _T('m') || ch == _T('M'))
 				lval *= 1000L;
 			m_cinfo.mem->max_memory_to_use = lval * 1000L;
 		}
-		else if (keymatch(arg, "dc-scan-opt", 3)) {
+		else if (keymatch(arg, _T("dc-scan-opt"), 3)) {
 			if (++argn >= argc) {      /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_DC_SCAN_OPT);
 				usage();
 			}
-			jpeg_c_set_int_param(&m_cinfo, JINT_DC_SCAN_OPT_MODE, atoi(argv[argn]));
+			jpeg_c_set_int_param(&m_cinfo, JINT_DC_SCAN_OPT_MODE, _ttoi(argv[argn]));
 		}
-		else if (keymatch(arg, "optimize", 1) || keymatch(arg, "optimise", 1)) {
+		else if (keymatch(arg, _T("optimize"), 1) || keymatch(arg, _T("optimise"), 1)) {
 			/* Enable entropy parm optimization. */
 #ifdef ENTROPY_OPT_SUPPORTED
 			m_cinfo.optimize_coding = TRUE;
@@ -479,7 +479,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_OPTIMIZE);
 #endif
 		}
-		else if (keymatch(arg, "outfile", 4)) {
+		else if (keymatch(arg, _T("outfile"), 4)) {
 			/* Set output file name. */
 			if (++argn >= argc) {      /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_OUTFILE);
@@ -487,7 +487,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			}
 			m_outfilename = argv[argn]; /* save it away for later use */
 		}
-		else if (keymatch(arg, "progressive", 1)) {
+		else if (keymatch(arg, _T("progressive"), 1)) {
 			/* Select simple progressive mode. */
 #ifdef C_PROGRESSIVE_SUPPORTED
 			simple_progressive = TRUE;
@@ -496,7 +496,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_PROGRESSIVE);
 #endif
 		}
-		else if (keymatch(arg, "memdst", 2)) {
+		else if (keymatch(arg, _T("memdst"), 2)) {
 			/* Use in-memory destination manager */
 #if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)
 			m_memdst = TRUE;
@@ -504,7 +504,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MEMDST);
 #endif
 		}
-		else if (keymatch(arg, "quality", 1)) {
+		else if (keymatch(arg, _T("quality"), 1)) {
 			/* Quality ratings (quantization table scaling factors). */
 			if (++argn >= argc) {      /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_QUALITY);
@@ -513,7 +513,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			qualityarg = argv[argn];
 
 		}
-		else if (keymatch(arg, "qslots", 2)) {
+		else if (keymatch(arg, _T("qslots"), 2)) {
 			/* Quantization table slot numbers. */
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_QSLOTS);
@@ -525,7 +525,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			 * default quant table numbers.
 			 */
 		}
-		else if (keymatch(arg, "qtables", 2)) {
+		else if (keymatch(arg, _T("qtables"), 2)) {
 			/* Quantization tables fetched from file. */
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_QTABLES);
@@ -534,16 +534,16 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			qtablefile = argv[argn];
 			/* We postpone actually reading the file in case -quality comes later. */
 		}
-		else if (keymatch(arg, "report", 3)) {
+		else if (keymatch(arg, _T("report"), 3)) {
 			m_report = TRUE;
 		}
-		else if (keymatch(arg, "quant-table", 7)) {
+		else if (keymatch(arg, _T("quant-table"), 7)) {
 			int val;
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_QUANT_TABLE);
 				usage();
 			}
-			val = atoi(argv[argn]);
+			val = _ttoi(argv[argn]);
 			jpeg_c_set_int_param(&m_cinfo, JINT_BASE_QUANT_TBL_IDX, val);
 			if (jpeg_c_get_int_param(&m_cinfo, JINT_BASE_QUANT_TBL_IDX) != val) {
 				ERREXIT1(&m_cinfo, JERR_CJPEG_SWITCH_INVALID_QUANT_TABLE, val);
@@ -551,21 +551,21 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			}
 			jpeg_set_quality(&m_cinfo, 75, TRUE);
 		}
-		else if (keymatch(arg, "quant-baseline", 7)) {
+		else if (keymatch(arg, _T("quant-baseline"), 7)) {
 			/* Force quantization table to meet baseline requirements */
 			force_baseline = TRUE;
 
 		}
-		else if (keymatch(arg, "restart", 1)) {
+		else if (keymatch(arg, _T("restart"), 1)) {
 			/* Restart interval in MCU rows (or in MCUs with 'b'). */
 			long lval;
-			char ch = 'x';
+			TCHAR ch = 'x';
 
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_RESTART);
 				usage();
 			}
-			if (sscanf_s(argv[argn], "%ld%c", &lval, &ch, 1) < 1) {
+			if (_stscanf_s(argv[argn], _T("%ld%c"), &lval, &ch, 1) < 1) {
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_INVALID_RESTART);
 				usage();
 			}
@@ -573,7 +573,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_INVALID_RESTART);
 				usage();
 			}
-			if (ch == 'b' || ch == 'B') {
+			if (ch == _T('b') || ch == _T('B')) {
 				m_cinfo.restart_interval = (unsigned int)lval;
 				m_cinfo.restart_in_rows = 0; /* else prior '-restart n' overrides me */
 			}
@@ -582,12 +582,12 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 				/* restart_interval will be computed during startup */
 			}
 		}
-		else if (keymatch(arg, "revert", 3)) {
+		else if (keymatch(arg, _T("revert"), 3)) {
 			/* revert to old JPEG default */
 			jpeg_c_set_int_param(&m_cinfo, JINT_COMPRESS_PROFILE, JCP_FASTEST);
 			jpeg_set_defaults(&m_cinfo);
 		}
-		else if (keymatch(arg, "sample", 2)) {
+		else if (keymatch(arg, _T("sample"), 2)) {
 			/* Set sampling factors. */
 			if (++argn >= argc) {       /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_SAMPLE);
@@ -600,7 +600,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			 */
 
 		}
-		else if (keymatch(arg, "scans", 4)) {
+		else if (keymatch(arg, _T("scans"), 4)) {
 			/* Set scan script. */
 #ifdef C_MULTISCAN_FILES_SUPPORTED
 			if (++argn >= argc) {       /* advance to next argument */
@@ -613,7 +613,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_SCANS);
 #endif
 		}
-		else if (keymatch(arg, "smooth", 2)) {
+		else if (keymatch(arg, _T("smooth"), 2)) {
 			/* Set input smoothing factor. */
 			int val;
 
@@ -621,7 +621,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_SMOOTH);
 				usage();
 			}
-			if (sscanf_s(argv[argn], "%d", &val) != 1) {
+			if (_stscanf_s(argv[argn], _T("%d"), &val) != 1) {
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_INVALID_SMOOTH);
 				usage();
 			}
@@ -631,38 +631,38 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			}
 			m_cinfo.smoothing_factor = val;
 		}
-		else if (keymatch(arg, "strict", 2)) {
+		else if (keymatch(arg, _T("strict"), 2)) {
 			m_strict = TRUE;
 		}
-		else if (keymatch(arg, "targa", 1)) {
+		else if (keymatch(arg, _T("targa"), 1)) {
 			/* Input file is Targa format. */
 			m_is_targa = TRUE;
 
 		}
-		else if (keymatch(arg, "notrellis-dc", 11)) {
+		else if (keymatch(arg, _T("notrellis-dc"), 11)) {
 			/* disable trellis quantization */
 			jpeg_c_set_bool_param(&m_cinfo, JBOOLEAN_TRELLIS_QUANT_DC, FALSE);
 
 		}
-		else if (keymatch(arg, "notrellis", 1)) {
+		else if (keymatch(arg, _T("notrellis"), 1)) {
 			/* disable trellis quantization */
 			jpeg_c_set_bool_param(&m_cinfo, JBOOLEAN_TRELLIS_QUANT, FALSE);
 
 		}
-		else if (keymatch(arg, "trellis-dc-ver-weight", 12)) {
+		else if (keymatch(arg, _T("trellis-dc-ver-weight"), 12)) {
 			if (++argn >= argc) {      /* advance to next argument */
 				ERREXIT(&m_cinfo, JERR_CJPEG_SWITCH_MISSING_TRELLIS_DC_VER_WEIGHT);
 				usage();
 			}
-			jpeg_c_set_float_param(&m_cinfo, JFLOAT_TRELLIS_DELTA_DC_WEIGHT, static_cast<float>(atof(argv[argn])));
+			jpeg_c_set_float_param(&m_cinfo, JFLOAT_TRELLIS_DELTA_DC_WEIGHT, static_cast<float>(_ttof(argv[argn])));
 
 		}
-		else if (keymatch(arg, "trellis-dc", 9)) {
+		else if (keymatch(arg, _T("trellis-dc"), 9)) {
 			/* enable DC trellis quantization */
 			jpeg_c_set_bool_param(&m_cinfo, JBOOLEAN_TRELLIS_QUANT_DC, TRUE);
 
 		}
-		else if (keymatch(arg, "tune-psnr", 6)) {
+		else if (keymatch(arg, _T("tune-psnr"), 6)) {
 			jpeg_c_set_int_param(&m_cinfo, JINT_BASE_QUANT_TBL_IDX, 1);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 9.0);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 0.0);
@@ -670,7 +670,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			jpeg_set_quality(&m_cinfo, 75, TRUE);
 
 		}
-		else if (keymatch(arg, "tune-ssim", 6)) {
+		else if (keymatch(arg, _T("tune-ssim"), 6)) {
 			jpeg_c_set_int_param(&m_cinfo, JINT_BASE_QUANT_TBL_IDX, 1);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 11.5);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 12.75);
@@ -678,7 +678,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			jpeg_set_quality(&m_cinfo, 75, TRUE);
 
 		}
-		else if (keymatch(arg, "tune-ms-ssim", 6)) {
+		else if (keymatch(arg, _T("tune-ms-ssim"), 6)) {
 			jpeg_c_set_int_param(&m_cinfo, JINT_BASE_QUANT_TBL_IDX, 3);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 12.0);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 13.0);
@@ -686,7 +686,7 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			jpeg_set_quality(&m_cinfo, 75, TRUE);
 
 		}
-		else if (keymatch(arg, "tune-hvs-psnr", 6)) {
+		else if (keymatch(arg, _T("tune-hvs-psnr"), 6)) {
 			jpeg_c_set_int_param(&m_cinfo, JINT_BASE_QUANT_TBL_IDX, 3);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 14.75);
 			jpeg_c_set_float_param(&m_cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 16.5);
@@ -694,11 +694,11 @@ int CJpeg::parse_switches(int argc, char** argv, int last_file_arg_seen, boolean
 			jpeg_set_quality(&m_cinfo, 75, TRUE);
 
 		}
-		else if (keymatch(arg, "noovershoot", 11)) {
+		else if (keymatch(arg, _T("noovershoot"), 11)) {
 			jpeg_c_set_bool_param(&m_cinfo, JBOOLEAN_OVERSHOOT_DERINGING, FALSE);
 
 		}
-		else if (keymatch(arg, "nojfif", 6)) {
+		else if (keymatch(arg, _T("nojfif"), 6)) {
 			m_cinfo.write_JFIF_header = 0;
 		}
 		else {
@@ -803,7 +803,7 @@ void CJpeg::my_emit_message(j_common_ptr cinfo, int msg_level)
  * The main program.
  */
 
-int CJpeg::cjpeg_main(int argc, char** argv)
+int CJpeg::cjpeg_main(int argc, TCHAR** argv)
 {
 #ifdef CJPEG_FUZZER
 	struct my_error_mgr myerr;
@@ -818,7 +818,7 @@ int CJpeg::cjpeg_main(int argc, char** argv)
 	JOCTET* icc_profile = NULL;
 	long icc_len = 0;
 	JDIMENSION num_scanlines;
-	char errBuffer[JMSG_LENGTH_MAX];
+	TCHAR errBuffer[JMSG_LENGTH_MAX];
 
 	/* On Mac, fetch a command line. */
 #ifdef USE_CCOMMAND
@@ -827,7 +827,7 @@ int CJpeg::cjpeg_main(int argc, char** argv)
 
 	m_progname = argv[0];
 	if (m_progname == NULL || m_progname[0] == 0)
-		m_progname = "cjpeg";         /* in case C library doesn't provide it */
+		m_progname = _T("cjpeg");         /* in case C library doesn't provide it */
 
 	  /* Initialize the JPEG compression object with default error handling. */
 	m_cinfo.err = jpeg_std_error(&jerr);
@@ -862,8 +862,8 @@ int CJpeg::cjpeg_main(int argc, char** argv)
 
 	/* Open the input file. */
 	if (file_index < argc) {
-		if (fopen_s(&m_input_file, argv[file_index], READ_BINARY) != 0) {
-			sprintf_s(errBuffer, JMSG_LENGTH_MAX, "failed to open input file:%s", argv[file_index]);
+		if (_tfopen_s(&m_input_file, argv[file_index], READ_BINARY) != 0) {
+			_stprintf_s(errBuffer, JMSG_LENGTH_MAX, _T("failed to open input file:%s"), argv[file_index]);
 			ERREXITS(&m_cinfo, JERR_CJPEG_INPUT_OPEN_FAIL, errBuffer);
 		}
 	}
@@ -874,27 +874,27 @@ int CJpeg::cjpeg_main(int argc, char** argv)
 	OutputDebugLog(L"CJpeg::cjpeg_main start reading file\n");
 
 	if (m_icc_filename != NULL) {
-		fopen_s(&icc_file, m_icc_filename, READ_BINARY);
+		_tfopen_s(&icc_file, m_icc_filename, READ_BINARY);
 		if (icc_file == NULL) {
-			sprintf_s(errBuffer, JMSG_LENGTH_MAX, "failed to open %s", m_icc_filename);
+			_stprintf_s(errBuffer, JMSG_LENGTH_MAX, _T("failed to open %s"), m_icc_filename);
 			ERREXITS(&m_cinfo, JERR_CJPEG_ICC_FILE_OPEN_FAIL, errBuffer);
 		}
 		if (fseek(icc_file, 0, SEEK_END) < 0 ||
 			(icc_len = ftell(icc_file)) < 1 ||
 			fseek(icc_file, 0, SEEK_SET) < 0) {
 			fclose(icc_file);
-			sprintf_s(errBuffer, JMSG_LENGTH_MAX, "failed to determine ICC file size: %s", m_icc_filename);
+			_stprintf_s(errBuffer, JMSG_LENGTH_MAX, _T("failed to determine ICC file size: %s"), m_icc_filename);
 			ERREXITS(&m_cinfo, JERR_CJPEG_ICC_FILE_SIZE_FAIL, errBuffer);
 		}
 		if ((icc_profile = (JOCTET*)malloc(icc_len)) == NULL) {
 			fclose(icc_file);
-			sprintf_s(errBuffer, JMSG_LENGTH_MAX, "failed to allocate memory for ICC: %s", m_icc_filename);
+			_stprintf_s(errBuffer, JMSG_LENGTH_MAX, _T("failed to allocate memory for ICC: %s"), m_icc_filename);
 			ERREXITS(&m_cinfo, JERR_CJPEG_ICC_MALLOC, errBuffer);
 		}
 		if (fread(icc_profile, icc_len, 1, icc_file) < 1) {
 			free(icc_profile);
 			fclose(icc_file);
-			sprintf_s(errBuffer, JMSG_LENGTH_MAX, "failed to read from ICC file: %s", m_icc_filename);
+			_stprintf_s(errBuffer, JMSG_LENGTH_MAX, _T("failed to read from ICC file: %s"), m_icc_filename);
 			ERREXITS(&m_cinfo, JERR_CJPEG_ICC_READ, errBuffer);
 		}
 		fclose(icc_file);
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.h b/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.h
index 7f69af0..a055732 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.h
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/cjpeg.h
@@ -8,11 +8,11 @@ public:
 	CJpeg();
 	cjpeg_source_ptr select_file_type(FILE* infile);
 	void usage();
-	int parse_switches(int argc, char** argv, int last_file_arg_seen, boolean for_real);
+	int parse_switches(int argc, TCHAR** argv, int last_file_arg_seen, boolean for_real);
 	static void error_exit(j_common_ptr cinfo);
 	static void output_message(j_common_ptr cinfo);
 	static void my_emit_message(j_common_ptr cinfo, int msg_level);
-	int cjpeg_main(int argc, char** argv);
+	int cjpeg_main(int argc, TCHAR** argv);
 
 	jpeg_compress_struct m_cinfo;
 
@@ -25,9 +25,9 @@ public:
 	CSyncObject* m_pSyncAbort;
 	bool* m_Paused;
 
-	char* m_progname;    /* program name for error messages */	// const
-	char* m_icc_filename;      /* for -icc switch */
-	char* m_outfilename;       /* for -outfile switch */
+	TCHAR* m_progname;    /* program name for error messages */	// const
+	TCHAR* m_icc_filename;      /* for -icc switch */
+	TCHAR* m_outfilename;       /* for -outfile switch */
 	boolean m_memdst;                 /* for -memdst switch */
 	boolean m_report;                 /* for -report switch */
 	boolean m_strict;                 /* for -strict switch */
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/jconfigint.h b/MozJpegGUI/MozJpegGUI/mozJpeg/jconfigint.h
index 0c28e70..d9fa499 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/jconfigint.h
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/jconfigint.h
@@ -1,5 +1,5 @@
 /* libjpeg-turbo build number */
-#define BUILD  "20231203"
+#define BUILD  _T("20231203")
 
 /* Compiler's inline keyword */
 #undef inline
@@ -11,10 +11,10 @@
 //#define THREAD_LOCAL  __declspec(thread)
 
 /* Define to the full name of this package. */
-#define PACKAGE_NAME  "mozjpeg"
+#define PACKAGE_NAME  _T("mozjpeg")
 
 /* Version number of package */
-#define VERSION  "4.1.1"
+#define VERSION  _T("4.1.1")
 
 /* The size of `size_t', as computed by sizeof. */
 #define SIZEOF_SIZE_T  8
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/jversion.h b/MozJpegGUI/MozJpegGUI/mozJpeg/jversion.h
index 342f6fd..30fe307 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/jversion.h
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/jversion.h
@@ -15,15 +15,15 @@
 
 #if JPEG_LIB_VERSION >= 80
 
-#define JVERSION        "8d  15-Jan-2012"
+#define JVERSION        _T("8d  15-Jan-2012")
 
 #elif JPEG_LIB_VERSION >= 70
 
-#define JVERSION        "7  27-Jun-2009"
+#define JVERSION        _T("7  27-Jun-2009")
 
 #else
 
-#define JVERSION        "6b  27-Mar-1998"
+#define JVERSION        _T("6b  27-Mar-1998")
 
 #endif
 
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/rdpng.cpp b/MozJpegGUI/MozJpegGUI/mozJpeg/rdpng.cpp
index ab8e69d..de8d13c 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/rdpng.cpp
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/rdpng.cpp
@@ -87,7 +87,7 @@ start_input_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
     source->info_ptr = png_create_info_struct(source->png_ptr);
 
     if (!source->png_ptr || !source->info_ptr) {
-        ERREXITS(cinfo, JERR_PNG_ERROR, "Can't create read/info_struct");
+        ERREXITS(cinfo, JERR_PNG_ERROR, _T("Can't create read/info_struct"));
         return;
     }
 
@@ -103,7 +103,7 @@ start_input_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
                  &bit_depth, &color_type, NULL, NULL, NULL);
 
     if (width > 65535 || height > 65535) {
-        ERREXITS(cinfo, JERR_PNG_ERROR, "Image too large");
+        ERREXITS(cinfo, JERR_PNG_ERROR, _T("Image too large"));
         return;
     }
 
diff --git a/MozJpegGUI/MozJpegGUI/mozJpeg/rdswitch.cpp b/MozJpegGUI/MozJpegGUI/mozJpeg/rdswitch.cpp
index a59093f..099d6ce 100644
--- a/MozJpegGUI/MozJpegGUI/mozJpeg/rdswitch.cpp
+++ b/MozJpegGUI/MozJpegGUI/mozJpeg/rdswitch.cpp
@@ -79,7 +79,7 @@ static int q_scale_factor[NUM_QUANT_TBLS] = {100, 100, 100, 100};
 #endif
 
 GLOBAL(boolean)
-read_quant_tables(j_compress_ptr cinfo, char *filename, boolean force_baseline)
+read_quant_tables(j_compress_ptr cinfo, TCHAR *filename, boolean force_baseline)
 /* Read a set of quantization tables from the specified file.
  * The file is plain ASCII text: decimal numbers with whitespace between.
  * Comments preceded by '#' may be included in the file.
@@ -95,23 +95,23 @@ read_quant_tables(j_compress_ptr cinfo, char *filename, boolean force_baseline)
   long val;
   unsigned int table[DCTSIZE2];
 
-  fopen_s(&fp, filename, "r");
+  _tfopen_s(&fp, filename, _T("r"));
   if (fp == NULL) {
-    fprintf(stderr, "Can't open table file %s\n", filename);
+    _ftprintf(stderr, _T("Can't open table file %s\n"), filename);
     return FALSE;
   }
   tblno = 0;
 
   while (read_text_integer(fp, &val, &termchar)) { /* read 1st element of table */
     if (tblno >= NUM_QUANT_TBLS) {
-      fprintf(stderr, "Too many tables in file %s\n", filename);
+      _ftprintf(stderr, _T("Too many tables in file %s\n"), filename);
       fclose(fp);
       return FALSE;
     }
     table[0] = (unsigned int) val;
     for (i = 1; i < DCTSIZE2; i++) {
       if (! read_text_integer(fp, &val, &termchar)) {
-        fprintf(stderr, "Invalid table data in file %s\n", filename);
+        _ftprintf(stderr, _T("Invalid table data in file %s\n"), filename);
         fclose(fp);
         return FALSE;
       }
@@ -128,7 +128,7 @@ read_quant_tables(j_compress_ptr cinfo, char *filename, boolean force_baseline)
   }
 
   if (termchar != EOF) {
-    fprintf(stderr, "Non-numeric data in file %s\n", filename);
+    _ftprintf(stderr, _T("Non-numeric data in file %s\n"), filename);
     fclose(fp);
     return FALSE;
   }
@@ -170,7 +170,7 @@ read_scan_integer (FILE *file, long *result, int *termchar)
 
 
 GLOBAL(boolean)
-read_scan_script (j_compress_ptr cinfo, char *filename)
+read_scan_script (j_compress_ptr cinfo, TCHAR *filename)
 /* Read a scan script from the specified text file.
  * Each entry in the file defines one scan to be emitted.
  * Entries are separated by semicolons ';'.
@@ -194,9 +194,9 @@ read_scan_script (j_compress_ptr cinfo, char *filename)
 #define MAX_SCANS  100          /* quite arbitrary limit */
   jpeg_scan_info scans[MAX_SCANS];
 
-  fopen_s(&fp, filename, "r");
+  _tfopen_s(&fp, filename, _T("r"));
   if (fp == NULL) {
-    fprintf(stderr, "Can't open scan definition file %s\n", filename);
+    _ftprintf(stderr, _T("Can't open scan definition file %s\n"), filename);
     return FALSE;
   }
   scanptr = scans;
@@ -204,7 +204,7 @@ read_scan_script (j_compress_ptr cinfo, char *filename)
 
   while (read_scan_integer(fp, &val, &termchar)) {
     if (scanno >= MAX_SCANS) {
-      fprintf(stderr, "Too many scans defined in file %s\n", filename);
+      _ftprintf(stderr, _T("Too many scans defined in file %s\n"), filename);
       fclose(fp);
       return FALSE;
     }
@@ -212,7 +212,7 @@ read_scan_script (j_compress_ptr cinfo, char *filename)
     ncomps = 1;
     while (termchar == ' ') {
       if (ncomps >= MAX_COMPS_IN_SCAN) {
-        fprintf(stderr, "Too many components in one scan in file %s\n",
+        _ftprintf(stderr, _T("Too many components in one scan in file %s\n"),
                 filename);
         fclose(fp);
         return FALSE;
@@ -245,7 +245,7 @@ read_scan_script (j_compress_ptr cinfo, char *filename)
     }
     if (termchar != ';' && termchar != EOF) {
 bogus:
-      fprintf(stderr, "Invalid scan entry format in file %s\n", filename);
+      _ftprintf(stderr, _T("Invalid scan entry format in file %s\n"), filename);
       fclose(fp);
       return FALSE;
     }
@@ -253,7 +253,7 @@ bogus:
   }
 
   if (termchar != EOF) {
-    fprintf(stderr, "Non-numeric data in file %s\n", filename);
+    _ftprintf(stderr, _T("Non-numeric data in file %s\n"), filename);
     fclose(fp);
     return FALSE;
   }
@@ -521,7 +521,7 @@ jpeg_default_qtables (j_compress_ptr cinfo, boolean force_baseline)
 
 
 GLOBAL(boolean)
-set_quality_ratings (j_compress_ptr cinfo, char *arg, boolean force_baseline)
+set_quality_ratings (j_compress_ptr cinfo, TCHAR *arg, boolean force_baseline)
 /* Process a quality-ratings parameter string, of the form
  *     N[,N,...]
  * If there are more q-table slots than parameters, the last value is replicated.
@@ -529,14 +529,14 @@ set_quality_ratings (j_compress_ptr cinfo, char *arg, boolean force_baseline)
 {
   float val = 75.f;                 /* default value */
   int tblno;
-  char ch;
+  TCHAR ch;
 
   for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {
     if (*arg) {
-      ch = ',';                 /* if not set by sscanf, will be ',' */
-      if (sscanf_s(arg, "%f%c", &val, &ch, 1) < 1)
+      ch = _T(',');                 /* if not set by sscanf, will be ',' */
+      if (_stscanf_s(arg, _T("%f%c"), &val, &ch, 1) < 1)
         return FALSE;
-      if (ch != ',')            /* syntax check */
+      if (ch != _T(','))            /* syntax check */
         return FALSE;
       /* Convert user 0-100 rating to percentage scaling */
 #if JPEG_LIB_VERSION >= 70
@@ -544,7 +544,7 @@ set_quality_ratings (j_compress_ptr cinfo, char *arg, boolean force_baseline)
 #else
       q_scale_factor[tblno] = static_cast<int>(jpeg_float_quality_scaling(val));
 #endif
-      while (*arg && *arg++ != ','); /* advance to next segment of arg
+      while (*arg && *arg++ != _T(',')); /* advance to next segment of arg
                                         string */
     } else {
       /* reached end of parameter, set remaining factors to last value */
@@ -562,9 +562,9 @@ set_quality_ratings (j_compress_ptr cinfo, char *arg, boolean force_baseline)
      To make the quality setting more intuitive, disable subsampling when high-quality
      color is desired. */
   if (val >= 90) {
-    set_sample_factors(cinfo, "1x1");
+    set_sample_factors(cinfo, _T("1x1"));
   } else if (val >= 80) {
-    set_sample_factors(cinfo, "2x1");
+    set_sample_factors(cinfo, _T("2x1"));
   }
 
   return TRUE;
@@ -572,7 +572,7 @@ set_quality_ratings (j_compress_ptr cinfo, char *arg, boolean force_baseline)
 
 
 GLOBAL(boolean)
-set_quant_slots (j_compress_ptr cinfo, char *arg)
+set_quant_slots (j_compress_ptr cinfo, TCHAR *arg)
 /* Process a quantization-table-selectors parameter string, of the form
  *     N[,N,...]
  * If there are more components than parameters, the last value is replicated.
@@ -580,14 +580,14 @@ set_quant_slots (j_compress_ptr cinfo, char *arg)
 {
   int val = 0;                  /* default table # */
   int ci;
-  char ch;
+  TCHAR ch;
 
   for (ci = 0; ci < MAX_COMPONENTS; ci++) {
     if (*arg) {
-      ch = ',';                 /* if not set by sscanf, will be ',' */
-      if (sscanf_s(arg, "%d%c", &val, &ch, 1) < 1)
+      ch = _T(',');                 /* if not set by sscanf, will be ',' */
+      if (_stscanf_s(arg, _T("%d%c"), &val, &ch, 1) < 1)
         return FALSE;
-      if (ch != ',')            /* syntax check */
+      if (ch != _T(','))            /* syntax check */
         return FALSE;
       if (val < 0 || val >= NUM_QUANT_TBLS) {
         fprintf(stderr, "JPEG quantization tables are numbered 0..%d\n",
@@ -595,7 +595,7 @@ set_quant_slots (j_compress_ptr cinfo, char *arg)
         return FALSE;
       }
       cinfo->comp_info[ci].quant_tbl_no = val;
-      while (*arg && *arg++ != ','); /* advance to next segment of arg
+      while (*arg && *arg++ != _T(',')); /* advance to next segment of arg
                                         string */
     } else {
       /* reached end of parameter, set remaining components to last table */
@@ -607,29 +607,29 @@ set_quant_slots (j_compress_ptr cinfo, char *arg)
 
 
 GLOBAL(boolean)
-set_sample_factors (j_compress_ptr cinfo, char *arg)
+set_sample_factors (j_compress_ptr cinfo, TCHAR *arg)
 /* Process a sample-factors parameter string, of the form
  *     HxV[,HxV,...]
  * If there are more components than parameters, "1x1" is assumed for the rest.
  */
 {
   int ci, val1, val2;
-  char ch1, ch2;
+  TCHAR ch1, ch2;
 
   for (ci = 0; ci < MAX_COMPONENTS; ci++) {
     if (*arg) {
-      ch2 = ',';                /* if not set by sscanf, will be ',' */
-      if (sscanf_s(arg, "%d%c%d%c", &val1, &ch1, 1, &val2, &ch2, 1) < 3)
+      ch2 = _T(',');                /* if not set by sscanf, will be ',' */
+      if (_stscanf_s(arg, _T("%d%c%d%c"), &val1, &ch1, 1, &val2, &ch2, 1) < 3)
         return FALSE;
-      if ((ch1 != 'x' && ch1 != 'X') || ch2 != ',') /* syntax check */
+      if ((ch1 != _T('x') && ch1 != _T('X')) || ch2 != _T(',')) /* syntax check */
         return FALSE;
       if (val1 <= 0 || val1 > 4 || val2 <= 0 || val2 > 4) {
-        fprintf(stderr, "JPEG sampling factors must be 1..4\n");
+        _ftprintf(stderr, _T("JPEG sampling factors must be 1..4\n"));
         return FALSE;
       }
       cinfo->comp_info[ci].h_samp_factor = val1;
       cinfo->comp_info[ci].v_samp_factor = val2;
-      while (*arg && *arg++ != ',');  /* advance to next segment of arg
+      while (*arg && *arg++ != _T(','));  /* advance to next segment of arg
                                          string */
     } else {
       /* reached end of parameter, set remaining components to 1x1 sampling */
diff --git a/x64/include/jerror.h b/x64/include/jerror.h
index 4c2736b..66fc665 100644
--- a/x64/include/jerror.h
+++ b/x64/include/jerror.h
@@ -271,8 +271,8 @@ JMESSAGE(JERR_BAD_DROP_SAMPLING,
    (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))
 #define ERREXITS(cinfo, code, str) \
   ((cinfo)->err->msg_code = (code), \
-   strncpy_s((cinfo)->err->msg_parm.s, JMSG_STR_PARM_MAX - 1, (str), JMSG_STR_PARM_MAX), \
-   (cinfo)->err->msg_parm.s[JMSG_STR_PARM_MAX - 1] = '\0', \
+   _tcsncpy_s((cinfo)->err->msg_parm.s, JMSG_STR_PARM_MAX - 1, (str), JMSG_STR_PARM_MAX), \
+   (cinfo)->err->msg_parm.s[JMSG_STR_PARM_MAX - 1] = _T('\0'), \
    (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))
 
 #define MAKESTMT(stuff)         do { stuff } while (0)
diff --git a/x64/include/jpeglib.h b/x64/include/jpeglib.h
index 16260d4..f69abb2 100644
--- a/x64/include/jpeglib.h
+++ b/x64/include/jpeglib.h
@@ -787,7 +787,7 @@ struct jpeg_error_mgr {
 #define JMSG_STR_PARM_MAX  80
   union {
     int i[8];
-    char s[JMSG_STR_PARM_MAX];
+    TCHAR s[JMSG_STR_PARM_MAX];
   } msg_parm;
 
   /* Standard state variables for error facility */
diff --git a/x64/include/png.h b/x64/include/png.h
index cfc4841..8bc33c0 100644
--- a/x64/include/png.h
+++ b/x64/include/png.h
@@ -278,8 +278,8 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.6.40"
-#define PNG_HEADER_VERSION_STRING " libpng version 1.6.40 - June 21, 2023\n"
+#define PNG_LIBPNG_VER_STRING _T("1.6.40")
+#define PNG_HEADER_VERSION_STRING _T(" libpng version 1.6.40 - June 21, 2023\n")
 
 #define PNG_LIBPNG_VER_SONUM   16
 #define PNG_LIBPNG_VER_DLLNUM  16
diff --git a/x64/include/pngconf.h b/x64/include/pngconf.h
index 6671e3c..6665ac4 100644
--- a/x64/include/pngconf.h
+++ b/x64/include/pngconf.h
@@ -587,7 +587,7 @@ typedef const png_uint_16     * png_const_uint_16p;
 typedef png_int_16            * png_int_16p;
 typedef const png_int_16      * png_const_int_16p;
 typedef char                  * png_charp;
-typedef const char            * png_const_charp;
+typedef const TCHAR            * png_const_charp;
 typedef png_fixed_point       * png_fixed_point_p;
 typedef const png_fixed_point * png_const_fixed_point_p;
 typedef size_t                * png_size_tp;
diff --git a/x86/include/jerror.h b/x86/include/jerror.h
index c5f4dbe..dcf8cc6 100644
--- a/x86/include/jerror.h
+++ b/x86/include/jerror.h
@@ -271,8 +271,8 @@ JMESSAGE(JERR_BAD_DROP_SAMPLING,
    (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))
 #define ERREXITS(cinfo, code, str) \
   ((cinfo)->err->msg_code = (code), \
-   strncpy_s((cinfo)->err->msg_parm.s, JMSG_STR_PARM_MAX-1, (str), JMSG_STR_PARM_MAX), \
-   (cinfo)->err->msg_parm.s[JMSG_STR_PARM_MAX - 1] = '\0', \
+   _tcsncpy_s((cinfo)->err->msg_parm.s, JMSG_STR_PARM_MAX-1, (str), JMSG_STR_PARM_MAX), \
+   (cinfo)->err->msg_parm.s[JMSG_STR_PARM_MAX - 1] = _T('\0'), \
    (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))
 
 #define MAKESTMT(stuff)         do { stuff } while (0)
diff --git a/x86/include/jpeglib.h b/x86/include/jpeglib.h
index 16260d4..f69abb2 100644
--- a/x86/include/jpeglib.h
+++ b/x86/include/jpeglib.h
@@ -787,7 +787,7 @@ struct jpeg_error_mgr {
 #define JMSG_STR_PARM_MAX  80
   union {
     int i[8];
-    char s[JMSG_STR_PARM_MAX];
+    TCHAR s[JMSG_STR_PARM_MAX];
   } msg_parm;
 
   /* Standard state variables for error facility */
diff --git a/x86/include/png.h b/x86/include/png.h
index cfc4841..8bc33c0 100644
--- a/x86/include/png.h
+++ b/x86/include/png.h
@@ -278,8 +278,8 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.6.40"
-#define PNG_HEADER_VERSION_STRING " libpng version 1.6.40 - June 21, 2023\n"
+#define PNG_LIBPNG_VER_STRING _T("1.6.40")
+#define PNG_HEADER_VERSION_STRING _T(" libpng version 1.6.40 - June 21, 2023\n")
 
 #define PNG_LIBPNG_VER_SONUM   16
 #define PNG_LIBPNG_VER_DLLNUM  16
diff --git a/x86/include/pngconf.h b/x86/include/pngconf.h
index 6671e3c..6665ac4 100644
--- a/x86/include/pngconf.h
+++ b/x86/include/pngconf.h
@@ -587,7 +587,7 @@ typedef const png_uint_16     * png_const_uint_16p;
 typedef png_int_16            * png_int_16p;
 typedef const png_int_16      * png_const_int_16p;
 typedef char                  * png_charp;
-typedef const char            * png_const_charp;
+typedef const TCHAR            * png_const_charp;
 typedef png_fixed_point       * png_fixed_point_p;
 typedef const png_fixed_point * png_const_fixed_point_p;
 typedef size_t                * png_size_tp;
